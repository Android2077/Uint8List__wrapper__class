import 'dart:io';
import 'dart:typed_data';         //для "Uint8List"
import 'Uint8List__class.dart';  



void main()
{

  //******************************************************************Uint8List__class:Начало*********************************************************************

  //Это класс обьертка над "сырым" буффером Uint8List - на подобие std::vector<unsigned char> или std::vector<uint8_t> из C++.


  //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  //Данный класс можно превратить простой автозаменой типа Uint8List в класс друого любой и базовых типа: Float23List, In16List ... итд.
  //С одним НЮАНСОМ: методы: insert_from_String, set_Buffer_Value_by_UTF8_from_String, push_back_from_String, decode_UTF8_to_String - нужно будет удалить, так как они актуальны только для работы с буффером Uint8List - так как декодирование из String корректно происходит только в буффер из Uint типа - для других типов это или не имеет смысла, из кодирвка UTF-16 которая находится в String будет искажена при преобразовании ее в UTF-16 для таких типов буфферов, как Int8List - так как int здесь, как понятно знаковый тип, а значения UTF-8 находятся только от 0 до 254 для каждого байта.
  //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


  Uint8List__class Uint8List_class_ = new Uint8List__class();      //Создаем обьект класса.


  //Доступные методы:

  //set__Reserve_koef                     - устанавливает коэфициаент резервирования емкости. По умолачанию устаовлен 0.4.
  //set_Buffer_Wrap_around_class          - устанавливает любой внешний Uint8List буффер в данный класс, и класс как бы начинает работать вокруг него. Внутренний буффер используемый до этого - теоертически должен будет удален собрщиком мусора..
  //get__Native_Uint8List_ref             - возвращает ссылку на оригинальный внутренний буффер "Uint8List".
  //clear                                 - очистить буффер: просто обнуляет размер и емкость.
  //free                                  - просто обнуляет размер и емкость и зануляет внутренний буффер и инициализицрет пустой новый.

  //set_Buffer_Value                      - устанавливает значения из внешнего буффера "Uint8List" во внутренний. Все значния внутреннеого буффера затирются.
  //set_Buffer_Value_by_UTF8_from_String  - то же самое, что и "set_Buffer_Value", но внутри класса каждый элемент "String" декодируется в UTF-8 и помещается в "Uint8List".
  //push_back                             - добовляет значния в конец.
  //push_back_OneValue                    - добавляет одно значение в конец. Так как в Dart нет самостоятельной перменной типа uint8/int8 - то доавблять значение можно только использую Dart`овский int, поэтому нужно контролировать диапазон значений, который доавбляется, если даовбялется значение больше, чем влезает в один элемент буффера "Uint8List" - то это непредвиденное поведение.
  //push_back_from_String                 - тоже самое, что и "push_back", но внутри класса каждый элемент "String" декодируется в UTF-8 и помещается в "Uint8List".
  //insert                                - вставляет значения в произвольное место.
  //insert_OneValue                       - вставляет одно значение в произвольное место. Так как в Dart нет самостоятельной перменной типа uint8/int8 - то доавблять значение можно только использую Dart`овский int, поэтому нужно контролировать диапазон значений, который доавбляется, если даовбялется значение больше, чем влезает в один элемент буффера "Uint8List" - то это непредвиденное поведение.
  //insert_from_String                    - тоже самое, что и "insert", но внутри класса каждый элемент "String" декодируется в UTF-8 и помещается в "Uint8List".
  //pop_back                              - удаляет заданное кол-во элементов с конца.
  //erase                                 - удаляет один элемент из произвольного места.
  //erase_range                           - удаляет диапазон элементов из произвольного места.
  //erase_if                              - удаляет элементв по условию.
  //memcpy                                - копирует заданыне элементы из одного буффера "Uint8List" в другой.
  //memcmp                                - сравнивает заданыне элементы одного буффера "Uint8List" с другим.
  //get__element_value                    - возврашает значение элемента по его индексу.
  //size                                  - возвращает кол-во рабочих элементов.
  //capacity                              - возвращает размер емкости буффера.
  //reserve                               - резерирвует указанную емкость.
  //resize                                - изменяет размер рабочего буффера.
  //shrink_to_fit                         - Запрашивает у контейнера уменьшение объёма до соответствующего текущего размера.

  //find_substring                        - ищет первую поппавшуюся "подстроку" в указанном диапазоне, то есть последотваельность значений переданного буффера "Uint8List"
  //find_substring_to_List                - ищет все поппавшиеся "подстроки" в указанном диапазоне и помещает их в вектор, то есть последотваельность значений переданного буффера "Uint8List"
  //decode_UTF8_to_String                      - декодирует внутренний буффер, как UTF-8 последовательность в Dart`овский UTF-16 String и возвращает его.
  //print_only_WorkSize                   - выводит на консоль только "рабочие" элементы, то есть сооветсующие фактическому размеру Uint8List_class_.size(), а не вcю емкость буффера Uint8List_class_.capacity()

  //get__View_Type_Float32List            - возвращает view-представление внутреннеого "Uint8List", как "указатель" на буффер "Float32List". Вообщем, возвращается, как бы указатель на внутренний буффер, но при индексировании по этому указателю элементы по индексу как бы "кастуются" или приводются к типу запрашваемого буффера. ДЛЯ примера: есть внутренний буффер "Uint8List" - пусть из 10 элементов, теперь запрашивает "укзаатель" на этот буффер "pointer_view = get__View_Type_Float32List()". pointer_view[0] - будет означать, что мы поулчает дсотуп к значению не первого байта Uint8List, а к значению приведенному к "Float32" - то есть первые 4-байта "Uint8List" - будут приведены к типу "float32", соотвевенно pointer_view[1] - уже будут приведены 4 байта начиначиная с 4 байта буффера "Uint8List" итд. НО внутри проверки на кратность размера типа запрашиваемого буффера нет, поэтому НУЖНО котролироват подобный доступ, потому что, если сделать уже так - pointer_view[2] - то будет указывать на 8 байт буффера "Uint8List" и пытатся привести 4 байта "float32" начиная с 8 байта, а размер нашего буффера "Uint8List" всего 10 байт!!! Это будет естесвенно ошибка, в лучем услучае упадет в рантайме, в худщем продолжит работать с некорректным результатом.
  //get__View_Type_Float64List            - возвращает view-представление внутреннеого "Uint8List", как "указатель" на буффер "Float64List". Вообщем, возвращается, как бы указатель на внутренний буффер, но при индексировании по этому указателю элементы по индексу как бы "кастуются" или приводются к типу запрашваемого буффера. ДЛЯ примера: есть внутренний буффер "Uint8List" - пусть из 10 элементов, теперь запрашивает "укзаатель" на этот буффер "pointer_view = get__View_Type_Float32List()". pointer_view[0] - будет означать, что мы поулчает дсотуп к значению не первого байта Uint8List, а к значению приведенному к "Float32" - то есть первые 4-байта "Uint8List" - будут приведены к типу "float32", соотвевенно pointer_view[1] - уже будут приведены 4 байта начиначиная с 4 байта буффера "Uint8List" итд. НО внутри проверки на кратность размера типа запрашиваемого буффера нет, поэтому НУЖНО котролироват подобный доступ, потому что, если сделать уже так - pointer_view[2] - то будет указывать на 8 байт буффера "Uint8List" и пытатся привести 4 байта "float32" начиная с 8 байта, а размер нашего буффера "Uint8List" всего 10 байт!!! Это будет естесвенно ошибка, в лучем услучае упадет в рантайме, в худщем продолжит работать с некорректным результатом.
  //get__View_Type_Int8List               - возвращает view-представление внутреннеого "Uint8List", как "указатель" на буффер "Int8List".    Вообщем, возвращается, как бы указатель на внутренний буффер, но при индексировании по этому указателю элементы по индексу как бы "кастуются" или приводются к типу запрашваемого буффера. ДЛЯ примера: есть внутренний буффер "Uint8List" - пусть из 10 элементов, теперь запрашивает "укзаатель" на этот буффер "pointer_view = get__View_Type_Float32List()". pointer_view[0] - будет означать, что мы поулчает дсотуп к значению не первого байта Uint8List, а к значению приведенному к "Float32" - то есть первые 4-байта "Uint8List" - будут приведены к типу "float32", соотвевенно pointer_view[1] - уже будут приведены 4 байта начиначиная с 4 байта буффера "Uint8List" итд. НО внутри проверки на кратность размера типа запрашиваемого буффера нет, поэтому НУЖНО котролироват подобный доступ, потому что, если сделать уже так - pointer_view[2] - то будет указывать на 8 байт буффера "Uint8List" и пытатся привести 4 байта "float32" начиная с 8 байта, а размер нашего буффера "Uint8List" всего 10 байт!!! Это будет естесвенно ошибка, в лучем услучае упадет в рантайме, в худщем продолжит работать с некорректным результатом.
  //get__View_Type_Int16List              - возвращает view-представление внутреннеого "Uint8List", как "указатель" на буффер "Int16List".   Вообщем, возвращается, как бы указатель на внутренний буффер, но при индексировании по этому указателю элементы по индексу как бы "кастуются" или приводются к типу запрашваемого буффера. ДЛЯ примера: есть внутренний буффер "Uint8List" - пусть из 10 элементов, теперь запрашивает "укзаатель" на этот буффер "pointer_view = get__View_Type_Float32List()". pointer_view[0] - будет означать, что мы поулчает дсотуп к значению не первого байта Uint8List, а к значению приведенному к "Float32" - то есть первые 4-байта "Uint8List" - будут приведены к типу "float32", соотвевенно pointer_view[1] - уже будут приведены 4 байта начиначиная с 4 байта буффера "Uint8List" итд. НО внутри проверки на кратность размера типа запрашиваемого буффера нет, поэтому НУЖНО котролироват подобный доступ, потому что, если сделать уже так - pointer_view[2] - то будет указывать на 8 байт буффера "Uint8List" и пытатся привести 4 байта "float32" начиная с 8 байта, а размер нашего буффера "Uint8List" всего 10 байт!!! Это будет естесвенно ошибка, в лучем услучае упадет в рантайме, в худщем продолжит работать с некорректным результатом.
  //get__View_Type_Int32List              - возвращает view-представление внутреннеого "Uint8List", как "указатель" на буффер "Int32List".   Вообщем, возвращается, как бы указатель на внутренний буффер, но при индексировании по этому указателю элементы по индексу как бы "кастуются" или приводются к типу запрашваемого буффера. ДЛЯ примера: есть внутренний буффер "Uint8List" - пусть из 10 элементов, теперь запрашивает "укзаатель" на этот буффер "pointer_view = get__View_Type_Float32List()". pointer_view[0] - будет означать, что мы поулчает дсотуп к значению не первого байта Uint8List, а к значению приведенному к "Float32" - то есть первые 4-байта "Uint8List" - будут приведены к типу "float32", соотвевенно pointer_view[1] - уже будут приведены 4 байта начиначиная с 4 байта буффера "Uint8List" итд. НО внутри проверки на кратность размера типа запрашиваемого буффера нет, поэтому НУЖНО котролироват подобный доступ, потому что, если сделать уже так - pointer_view[2] - то будет указывать на 8 байт буффера "Uint8List" и пытатся привести 4 байта "float32" начиная с 8 байта, а размер нашего буффера "Uint8List" всего 10 байт!!! Это будет естесвенно ошибка, в лучем услучае упадет в рантайме, в худщем продолжит работать с некорректным результатом.
  //get__View_Type_Int64List              - возвращает view-представление внутреннеого "Uint8List", как "указатель" на буффер "Int64List".   Вообщем, возвращается, как бы указатель на внутренний буффер, но при индексировании по этому указателю элементы по индексу как бы "кастуются" или приводются к типу запрашваемого буффера. ДЛЯ примера: есть внутренний буффер "Uint8List" - пусть из 10 элементов, теперь запрашивает "укзаатель" на этот буффер "pointer_view = get__View_Type_Float32List()". pointer_view[0] - будет означать, что мы поулчает дсотуп к значению не первого байта Uint8List, а к значению приведенному к "Float32" - то есть первые 4-байта "Uint8List" - будут приведены к типу "float32", соотвевенно pointer_view[1] - уже будут приведены 4 байта начиначиная с 4 байта буффера "Uint8List" итд. НО внутри проверки на кратность размера типа запрашиваемого буффера нет, поэтому НУЖНО котролироват подобный доступ, потому что, если сделать уже так - pointer_view[2] - то будет указывать на 8 байт буффера "Uint8List" и пытатся привести 4 байта "float32" начиная с 8 байта, а размер нашего буффера "Uint8List" всего 10 байт!!! Это будет естесвенно ошибка, в лучем услучае упадет в рантайме, в худщем продолжит работать с некорректным результатом.
  //get__View_Type_Uint8List              - возвращает view-представление внутреннеого "Uint8List", как "указатель" на буффер "Uint8List".   Вообщем, возвращается, как бы указатель на внутренний буффер, но при индексировании по этому указателю элементы по индексу как бы "кастуются" или приводются к типу запрашваемого буффера. ДЛЯ примера: есть внутренний буффер "Uint8List" - пусть из 10 элементов, теперь запрашивает "укзаатель" на этот буффер "pointer_view = get__View_Type_Float32List()". pointer_view[0] - будет означать, что мы поулчает дсотуп к значению не первого байта Uint8List, а к значению приведенному к "Float32" - то есть первые 4-байта "Uint8List" - будут приведены к типу "float32", соотвевенно pointer_view[1] - уже будут приведены 4 байта начиначиная с 4 байта буффера "Uint8List" итд. НО внутри проверки на кратность размера типа запрашиваемого буффера нет, поэтому НУЖНО котролироват подобный доступ, потому что, если сделать уже так - pointer_view[2] - то будет указывать на 8 байт буффера "Uint8List" и пытатся привести 4 байта "float32" начиная с 8 байта, а размер нашего буффера "Uint8List" всего 10 байт!!! Это будет естесвенно ошибка, в лучем услучае упадет в рантайме, в худщем продолжит работать с некорректным результатом.
  //get__View_Type_Uint16List             - возвращает view-представление внутреннеого "Uint8List", как "указатель" на буффер "Uint16List".  Вообщем, возвращается, как бы указатель на внутренний буффер, но при индексировании по этому указателю элементы по индексу как бы "кастуются" или приводются к типу запрашваемого буффера. ДЛЯ примера: есть внутренний буффер "Uint8List" - пусть из 10 элементов, теперь запрашивает "укзаатель" на этот буффер "pointer_view = get__View_Type_Float32List()". pointer_view[0] - будет означать, что мы поулчает дсотуп к значению не первого байта Uint8List, а к значению приведенному к "Float32" - то есть первые 4-байта "Uint8List" - будут приведены к типу "float32", соотвевенно pointer_view[1] - уже будут приведены 4 байта начиначиная с 4 байта буффера "Uint8List" итд. НО внутри проверки на кратность размера типа запрашиваемого буффера нет, поэтому НУЖНО котролироват подобный доступ, потому что, если сделать уже так - pointer_view[2] - то будет указывать на 8 байт буффера "Uint8List" и пытатся привести 4 байта "float32" начиная с 8 байта, а размер нашего буффера "Uint8List" всего 10 байт!!! Это будет естесвенно ошибка, в лучем услучае упадет в рантайме, в худщем продолжит работать с некорректным результатом.
  //get__View_Type_Uint32List             - возвращает view-представление внутреннеого "Uint8List", как "указатель" на буффер "Uint32List".  Вообщем, возвращается, как бы указатель на внутренний буффер, но при индексировании по этому указателю элементы по индексу как бы "кастуются" или приводются к типу запрашваемого буффера. ДЛЯ примера: есть внутренний буффер "Uint8List" - пусть из 10 элементов, теперь запрашивает "укзаатель" на этот буффер "pointer_view = get__View_Type_Float32List()". pointer_view[0] - будет означать, что мы поулчает дсотуп к значению не первого байта Uint8List, а к значению приведенному к "Float32" - то есть первые 4-байта "Uint8List" - будут приведены к типу "float32", соотвевенно pointer_view[1] - уже будут приведены 4 байта начиначиная с 4 байта буффера "Uint8List" итд. НО внутри проверки на кратность размера типа запрашиваемого буффера нет, поэтому НУЖНО котролироват подобный доступ, потому что, если сделать уже так - pointer_view[2] - то будет указывать на 8 байт буффера "Uint8List" и пытатся привести 4 байта "float32" начиная с 8 байта, а размер нашего буффера "Uint8List" всего 10 байт!!! Это будет естесвенно ошибка, в лучем услучае упадет в рантайме, в худщем продолжит работать с некорректным результатом.
  //get__View_Type_Uint64List             - возвращает view-представление внутреннеого "Uint8List", как "указатель" на буффер "Uint64List".  Вообщем, возвращается, как бы указатель на внутренний буффер, но при индексировании по этому указателю элементы по индексу как бы "кастуются" или приводются к типу запрашваемого буффера. ДЛЯ примера: есть внутренний буффер "Uint8List" - пусть из 10 элементов, теперь запрашивает "укзаатель" на этот буффер "pointer_view = get__View_Type_Float32List()". pointer_view[0] - будет означать, что мы поулчает дсотуп к значению не первого байта Uint8List, а к значению приведенному к "Float32" - то есть первые 4-байта "Uint8List" - будут приведены к типу "float32", соотвевенно pointer_view[1] - уже будут приведены 4 байта начиначиная с 4 байта буффера "Uint8List" итд. НО внутри проверки на кратность размера типа запрашиваемого буффера нет, поэтому НУЖНО котролироват подобный доступ, потому что, если сделать уже так - pointer_view[2] - то будет указывать на 8 байт буффера "Uint8List" и пытатся привести 4 байта "float32" начиная с 8 байта, а размер нашего буффера "Uint8List" всего 10 байт!!! Это будет естесвенно ошибка, в лучем услучае упадет в рантайме, в худщем продолжит работать с некорректным результатом.




  //------------------------------------------------------------set_Buffer_Value:Begin---------------------------------------------------------------------

  //Устанавливает(копирует) значения из внешнего буффера "Uint8List" во внутренний. Все значния внутреннеого буффера затирются, НО, если устанавливаемый буффер меньше, чем, который есть внутри класса, то в конце за пределами установленного размера - может быть мусор.
  //ВАЖНО_1: Если размер буффера, который копируется во внутренний буффер класса МЕНЬШЕ, чем фактическая емкость(Uint8List_class_.capacity()) внутренного буффера класса - то перераспредления памяти не происходит. ЕСЛИ размер буффера, который копируется во внутренний буффер класса БОЛЬШЕ, чем фактическая емкость(Uint8List_class_.capacity()) внутренного буффера класса, что приводит к автоматическому перераспределению выделенного пространства для хранения.
  //ВАЖНО_2: В случае, если происходит перераспредление памяти, то все "указатели" View - ранее полученные из данного буффера становятся недейсвительными.


  Uint8List Uint8List_set = Uint8List.fromList([1,2,3,4,5]);      //Буффер значения, которые нужно установить.
  int size_set            = Uint8List_set.length;                 //Размер "рабочих" данных в буффере "Uint8List_set", котоыре нужно установить.

  Uint8List_class_.set_Buffer_Value(Uint8List_set, size_set);     //Вызываем.
  //------------------------------------------------------------set_Buffer_Value:End---------------------------------------------------------------------



  //--------------------------------------------------------set_Buffer_Value_by_UTF8_from_String:Begin---------------------------------------------------------------------

  //То же самое, что и "set_Buffer_Value", но внутри класса каждый элемент "String" декодируется в UTF-8 и помещается в "Uint8List".

  String String_set = "Hello_Привет";             //Строка которую нужно установить в качестве UTF-8 буффера "Uint8List".

  Uint8List_class_.set_Buffer_Value_by_UTF8_from_String(String_set);   //Вызываем.
  //--------------------------------------------------------set_Buffer_Value_by_UTF8_from_String:End---------------------------------------------------------------------



  //-------------------------------------------------------------------push_back:Begin---------------------------------------------------------------------
  //Добовляет элемент с указанным значния в конец буффера.
  //ВАЖНО_1: Это фактически увеличивает размер буффера на указанное кол-во элементов, что приводит к автоматическому перераспределению выделенного пространства для хранения - ТОЛЬКО ПРИ УСЛОВИИ, что новый размер буффера превышает текущую ёмкость(Uint8List_class_.capacity()).
  //ВАЖНО_2: В случае, если происходит перераспредление памяти, то все "указатели" View - ранее полученные из данного буффера становятся недейсвительными.

  Uint8List Uint8List_pushback = Uint8List.fromList([10, 20, 30]);          //Буффер который нужно доавбить в конец.
  int size__pushback           = Uint8List_pushback.length;                 //Размер "рабочих" данных в буффере "Uint8List_pushback", котоыре нужно доабвить.

  Uint8List_class_.push_back(Uint8List_pushback, size__pushback);          //Вызываем.
  //-------------------------------------------------------------------push_back:End---------------------------------------------------------------------


  //-------------------------------------------------------------------push_back_OneValue:Begin---------------------------------------------------------------------
  //Добавляет одно значение в конец. Так как в Dart нет самостоятельной перменной типа uint8/int8 - то доавблять значение можно только использую Dart`овский int, поэтому нужно контролировать диапазон значений, который доавбляется, если даовбялется значение больше, чем влезает в один элемент буффера "Uint8List" - то это непредвиденное поведение.
  //ВАЖНО_1: Это фактически увеличивает размер буффера на еденицу, что приводит к автоматическому перераспределению выделенного пространства для хранения - ТОЛЬКО ПРИ УСЛОВИИ, что новый размер буффера превышает текущую ёмкость(Uint8List_class_.capacity()).
  //ВАЖНО_2: В случае, если происходит перераспредление памяти, то все "указатели" View - ранее полученные из данного буффера становятся недейсвительными.

  
  int int_pushback_correct   = 150;
  //int int_pushback_incorrect = 300;  //Некорректное значение, так как выходит за диапазон значения Uint8.

  Uint8List_class_.push_back_OneValue(int_pushback_correct);          //Вызываем.
  //-------------------------------------------------------------------push_back_OneValue:End---------------------------------------------------------------------


  //-------------------------------------------------------------------push_back_from_String:Begin---------------------------------------------------------------------
  //Тоже самое, что и "push_back", но внутри класса каждый элемент "String" декодируется в UTF-8 и помещается в "Uint8List".

  String String_pushback = "String_pushback";                 //Строка которую нужно добавить в качестве UTF-8 буффера "Uint8List".

  Uint8List_class_.push_back_from_String(String_pushback);    //Вызываем.
  //-------------------------------------------------------------------push_back_from_String:End---------------------------------------------------------------------


  //-----------------------------------------------------------------------insert:Begin---------------------------------------------------------------------
  //Вставляет значения в произвольное место.
  //ВАЖНО_1: Это фактически увеличивает размер буффера на указанное кол-во элементов, что приводит к автоматическому перераспределению выделенного пространства для хранения - ТОЛЬКО ПРИ УСЛОВИИ, что новый размер буффера превышает текущую ёмкость(Uint8List_class_.capacity()).
  //ВАЖНО_2: В случае, если происходит перераспредление памяти, то все "указатели" View - ранее полученные из данного буффера становятся недейсвительными.

  
  //-------------------------------------------------------
  int Index_element_to_Insert_1 = 1;                                          //Номер элемента в буффере, отнсительно которого нужно вставить значение.
  insert_flag insert_flag_1     = insert_flag.Before;                          //After - значит значение нужно вставить ПОСЛЕ указанного "Index_element_to_Insert_1";  Before - значит значение нужно вставить ДО указанного "Index_element_to_Insert_1";
  Uint8List Uint8List_insert    = Uint8List.fromList([55, 66, 77]);           //Буффер который нужно вставить.
  int size__insert_1            = Uint8List_insert.length;                   //Размер "рабочих" данных в буффере "Uint8List_insert", котоыре нужно вставить.
  //-------------------------------------------------------


  Uint8List_class_.insert(Index_element_to_Insert_1, Uint8List_insert, size__insert_1, insert_flag_1);    //Вызываем.
  //-----------------------------------------------------------------------insert:End---------------------------------------------------------------------


  //-------------------------------------------------------------------insert_OneValue:Begin---------------------------------------------------------------------
  //Вставляет одно значение в произвольное место. Так как в Dart нет самостоятельной перменной типа uint8/int8 - то доавблять значение можно только использую Dart`овский int, поэтому нужно контролировать диапазон значений, который доавбляется, если даовбялется значение больше, чем влезает в один элемент буффера "Uint8List" - то это непредвиденное поведение.
  //ВАЖНО_1: Это фактически увеличивает размер буффера на еденицу, что приводит к автоматическому перераспределению выделенного пространства для хранения - ТОЛЬКО ПРИ УСЛОВИИ, что новый размер буффера превышает текущую ёмкость(Uint8List_class_.capacity()).
  //ВАЖНО_2: В случае, если происходит перераспредление памяти, то все "указатели" View - ранее полученные из данного буффера становятся недейсвительными.



  //-------------------------------------------------------
  int Index_element_to_Insert_2 = 1;                                           //Номер элемента в буффере, отнсительно которого нужно вставить значение.
  insert_flag insert_flag_2     = insert_flag.After;                           //After - значит значение нужно вставить ПОСЛЕ указанного "Index_element_to_Insert_1";  Before - значит значение нужно вставить ДО указанного "Index_element_to_Insert_1";

  int int_insert_correct        = 44;                                          //Значение, котороые нужно вставить.
  //int int_insert_incorrect    = 300;                                         //Некорректное значение, так как выходит за диапазон значения Uint8.
  //-------------------------------------------------------

  Uint8List_class_.insert_OneValue(Index_element_to_Insert_2, int_insert_correct, insert_flag_2);    //Вызываем.
  //-------------------------------------------------------------------insert_OneValue:End---------------------------------------------------------------------


  //-------------------------------------------------------------------insert_from_String:Begin---------------------------------------------------------------------
  //Тоже самое, что и "insert", но внутри класса каждый элемент "String" декодируется в UTF-8 и помещается в "Uint8List".

  //-------------------------------------------------------
  int Index_element_to_Insert_3 = 0;                               //Номер элемента в буффере, отнсительно которого нужно вставить значение.
  insert_flag insert_flag_3     = insert_flag.After;               //After - значит значение нужно вставить ПОСЛЕ указанного "Index_element_to_Insert_1";  Before - значит значение нужно вставить ДО указанного "Index_element_to_Insert_1";

  String String_insert          = "String_insert";                 //Строка которую нужно вставить в качестве UTF-8 буффера "Uint8List".
  //-------------------------------------------------------


  Uint8List_class_.insert_from_String(String_insert, Index_element_to_Insert_3, insert_flag_3);    //Вызываем.
  //-------------------------------------------------------------------insert_from_String:End---------------------------------------------------------------------


  //-----------------------------------------------------------------------pop_back:Begin---------------------------------------------------------------------
  //Удаляет заданное кол-во элементов с конца.
  //ВАЖНО_1: Не приводит к перераспределнию памяти.
  //ВАЖНО_2: Все "указатели" View - ранее полученные из данного буффера остаются валидными.

  int num_delete = 1;                             //Кол-во элементов, которые нужно удалить с конца буффера.

  Uint8List_class_.pop_back(num_delete);          //Вызываем.
  //-----------------------------------------------------------------------pop_back:End---------------------------------------------------------------------



  //------------------------------------------------------------------------erase:Begin---------------------------------------------------------------------
  //Удаляет один заданный элемент из произвольного места буффера.
  //ВАЖНО_1: Не приводит к перераспределнию памяти.
  //ВАЖНО_2: Все "указатели" View - ранее полученные из данного буффера остаются валидными.


  int Index_erase_element = 0;                     //Индекс удаляемого элемента.

  Uint8List_class_.erase(Index_erase_element);     //Вызываем.
  //------------------------------------------------------------------------erase:End---------------------------------------------------------------------


  //----------------------------------------------------------------------erase_range:Begin---------------------------------------------------------------------
  //Удаляет заданный диапазон элементов из произвольного места буффера.
  //ВАЖНО_1: Не приводит к перераспределнию памяти.
  //ВАЖНО_2: Все "указатели" View - ранее полученные из данного буффера остаются валидными.

  int Index_erase_Range_First = 0;                                       //Индекс начала удаляемого диапазона.
  int Index_erase_Range_Last  = Uint8List_class_.size()-1-1;             //Индекс конца удаляемого диапазона.


  //Uint8List_class_.erase_range(Index_erase_Range_First, Index_erase_Range_Last);     //Вызываем.

  //----------------------------------------------------------------------erase_range:End---------------------------------------------------------------------



  //-----------------------------------------------------------------------erase_if:Begin---------------------------------------------------------------------
  //Удаляет элементы по условию.
  //ВАЖНО_1: Не приводит к перераспределнию памяти.
  //ВАЖНО_2: Все "указатели" View - ранее полученные из данного буффера остаются валидными.

  bool Function(int value_compare) func_condition = (int value_compare)
  {
    //Функция, которая будевы вызватся для каждого элемента буффера.
    //value_compare - это значение элемента буффера для которого вызываетс функция.
    //Если value_compare - подходит под условие удаения, нужно из функции вернуть "true", если же уадялть не нужно, то "false".

    //Пример:
    //-------------------------------------------------------
    if(value_compare % 2 == 0)
    {
      return true;         //Если "value_compare" кратно 2, то удаляем.
    }
    else
    {
      return false;       //Значит не удаляем.
    }
    //-------------------------------------------------------

  };


  Uint8List_class_.erase_if(func_condition);                   //Вызываем.
  //-----------------------------------------------------------------------erase_if:End---------------------------------------------------------------------



  //-------------------------------------------------------------------memcpy:Begin---------------------------------------------------------------------
  //Копирует заданыне элементы из одного буффера "Uint8List" в другой.
  //Проверка на выходы за пределы буффера - не проверяется.
  //ВАЖНО_1: Не приводит к перераспределнию памяти.
  //ВАЖНО_2: Все "указатели" View - ранее полученные из данного буффера остаются валидными.


    //---------------------------------------------------------------
    Uint8List Uint8List_sorce  = Uint8List.fromList([220,230,240]);              //Буффер данные из которого нужно скопировать.
    Uint8List Uint8List_target = Uint8List_class_.get__Native_Uint8List_ref();   //Буффер в который нужно скопировать элементы из буффера "Uint8List_sorce".

    int Index_target           = 0;                                              //Индекс элемента в буффере "Uint8List_target" с котрого нужно вставить данные скопированные из буффера "Uint8List_sorce"
    int Index_source           = 0;                                              //Индекс элемента в буффере "Uint8List_sorce" c которого нужно скопировать данные в размере "size_copy"
    int size_copy              = 2;                                              //Кол-во элементов, которые нужно скопировать из буффера "Uint8List_sorce" начиная с указанного номера элемента "Index_source";
    //---------------------------------------------------------------


    Uint8List_class_.memcpy(Uint8List_target, Index_target, Uint8List_sorce, Index_source, size_copy);     //Вызываем.
  //-------------------------------------------------------------------memcpy:End---------------------------------------------------------------------


  print(Uint8List_class_.get__Native_Uint8List_ref());
  print('LAST2: ${Uint8List_class_.get__element_value(Uint8List_class_.size()-1)}');

  //-------------------------------------------------------------------memcmp:Begin---------------------------------------------------------------------
  //Cравнивает заданыне элементы одного буффера "Uint8List" с другим.

  //---------------------------------------------------------------
  Uint8List Uint8List_First  = Uint8List.fromList([220,230,240,99]);           //Буффер данные из которого нужно Сравнить-1
  Uint8List Uint8List_Second = Uint8List_class_.get__Native_Uint8List_ref();   //Буффер данные из которого нужно Сравнить-2

  int Index_First            = 3;                                              //Индекс элемента в буффере "Uint8List_First" с котрого нужно сравнить данные из буффера "Uint8List_Second"
  int Index_Second           = Uint8List_class_.size()-1;                      //Индекс элемента в буффере "Uint8List_Second" с котрого нужно сравнить данные из буффера "Uint8List_First"
  int cmp_size               = 1;                                               //Кол-во элементов(не байт), которые нужно скопировать из буффера "Uint8List_sorce" начиная с указанного номера элемента "Index_source";
  //---------------------------------------------------------------


  bool result_cmp = Uint8List_class_.memcmp(Uint8List_First, Index_First, Uint8List_Second, Index_Second, cmp_size);     //Вызываем.

  if(result_cmp == true)
  {
    print("matches");  //Значит сравниваемый участок памяти - Совпадает.
  }
  else
  {
    print("not match");  //Значит сравниваемый участок памяти - Совпадает.
  }
  //-------------------------------------------------------------------memcmp:End---------------------------------------------------------------------


  //-------------------------------------------------------------------get__element_value:Begin---------------------------------------------------------------------
  //Возврашает значение элемента по его индексу.

  int index_element = 2;                    //Индекс запрашиваемого элемета в буффере.

  int Index_value = Uint8List_class_.get__element_value(index_element);
  //-------------------------------------------------------------------get__element_value:End---------------------------------------------------------------------


  //-------------------------------------------------------------------size:Begin---------------------------------------------------------------------
  //Возвращает кол-во рабочих элементов.

   int size = Uint8List_class_.size();
  //-------------------------------------------------------------------size:End---------------------------------------------------------------------


  //-------------------------------------------------------------------capacity:Begin---------------------------------------------------------------------
  //Возвращает размер емкости буффера.

  int capacity = Uint8List_class_.capacity();
  //-------------------------------------------------------------------capacity:End---------------------------------------------------------------------


  //-------------------------------------------------------------------reserve:Begin---------------------------------------------------------------------
  //Резерирвует указанную емкость.
  //То есть к примеру: текущая емкость буффера .cpacity() 100 из них под сами "рабочие" элементы, то есть фактчиеский размер .size() равен 85, то есть 15 элементов зарезервированы, для того, чтобы меньше-реже было переаллокации памяти при доавблении элементов.
  //Если указать к примеру 200, то размер .size() так же останется 85, а вся емкость .capacity() будет теперь занимать 200, и 115 будет зарезервированы, то есть пока ничем не заняты.
  //ВАЖНО_1:Если указанное значение "reserve" Больше текущего значение емкости .capacity() - то происходит перераспределение памяти.Все "указатели" View - ранее полученные из данного буффера становятся недейсвительными.
  //ВАЖНО_2:Если указанное значение "reserve" Меньше текущего значение емкости .capacity() - то Абсолютно ничего не происходит.

  int reserve_value = 200;

  Uint8List_class_.reserve(reserve_value);
  //-------------------------------------------------------------------reserve:End---------------------------------------------------------------------


  //-------------------------------------------------------------------resize:Begin---------------------------------------------------------------------
  //Изменяет размер рабочего буффера.
  //ВАЖНО_1: Если устанавлеваемый размер Меньше фактического размера .size() и/или Меньше общей Емкости .cpacity(), то Общая емкость буффера .cpacity() Не меняется, перераспредления памяти не роисходит. Все "указатели" View - ранее полученные из данного буффера остаются валидными.
  //ВАЖНО_2: Если устанавлеваемый размер Больше Общей емкости .cpacity(), то, происходит перераспредления памяти. Все "указатели" View - ранее полученные из данного буффера становятся недейсвительными.

  int resize_value = 220;

  Uint8List_class_.resize(resize_value);
  //-------------------------------------------------------------------resize:End---------------------------------------------------------------------


  //-------------------------------------------------------------------shrink_to_fit:Begin---------------------------------------------------------------------
  //Запрашивает у контейнера уменьшение объёма до соответствующего текущего фактического размера.
  //То есть к примеру: текущая емкость буффера .cpacity() 100 из них под сами "рабочие" элементы, то есть фактчиеский размер .size() равен 85, при вызове shrink_to_fit() - емкость .cpacity() - будет уменьшена до фактичекого размера .size().

  Uint8List_class_.shrink_to_fit();
  //-------------------------------------------------------------------shrink_to_fit:End---------------------------------------------------------------------



  //-------------------------------------------------------------------find_substring:Begin---------------------------------------------------------------------
  //Ищет первую поппавшуюся "подстроку" в указанном диапазоне, то есть последотваельность значений переданного буффера "Uint8List"

  //---------------------------------------------------------------------
  Uint8List substr_1 = Uint8List.fromList([230, 103, 95]);       //"Подстрока", которую нужно найти.
  int substr_size_1  = substr_1.length;                          //Размер "подстроки" в элементах(не байтах).

  int Index_search_Range_First_1  = 1;                                       //Индекс начала диапазона в котором нужно искать подстроку.
  int Index_search_Range_Last_1   = Uint8List_class_.size()-1;               //Индекс конца диапазона в котором нужно искать подстроку..
  //---------------------------------------------------------------------


  int result_find = Uint8List_class_.find_substring(Index_search_Range_First_1, Index_search_Range_Last_1, substr_1, substr_size_1);  //Функуия возвращает "-1" в случае, если подстрока не найдена, и индекс элемента в искомом буффере с которого начинается найденная подстрока - если подстрока найдена.

  if(result_find == -1)
  {
    print("substring not found"); //Значит подстрока в указанном диапазоне не найдена.
  }
  else
  {
    print('substring found: ${result_find}'); //Значит подстрока в указанном диапазоне не найдена.
  }
  //-------------------------------------------------------------------find_substring:End---------------------------------------------------------------------


  //----------------------------------------------------------------find_substring_to_List:Begin---------------------------------------------------------------------
  //Ищет все поппавшиеся "подстроки" в указанном диапазоне и помещает их в вектор, то есть последотваельность значений переданного буффера "Uint8List"

  //---------------------------------------------------------------------
  Uint8List substr_2   = Uint8List.fromList([200, 115, 95]);       //"Подстрока"

  Uint8List substr_p   = Uint8List.view(substr_2.buffer, 1,1);               //Получим "указатель" на второй элемент существующего буффера, который нужно найти.
  int substr_size_2    = 1;                                                  //Размер "подстроки" в элементах(не байтах).

  int Index_search_Range_First_2  = 1;                                       //Индекс начала диапазона в котором нужно искать подстроку.
  int Index_search_Range_Last_2   = Uint8List_class_.size()-1;               //Индекс конца диапазона в котором нужно искать подстроку..

  List<int>vec__result = [];                                                 //Сюда функция добавить в конец результаты поиска в виде Индексов элеменнтов в буффере, с которых была найдена указанная подстрока.
  //---------------------------------------------------------------------


  bool result_bool = Uint8List_class_.find_substring_to_List(Index_search_Range_First_2, Index_search_Range_Last_2, substr_p, substr_size_2, vec__result);  //Функуия возвращает "-1" в случае, если подстрока не найдена, и индекс элемента в искомом буффере с которого начинается найденная подстрока - если подстрока найдена.

  if(result_bool == false)
  {
    print("substring not found"); //Значит подстрока в указанном диапазоне не найдена.
  }
  else
  {
    for(int i=0; i < vec__result.length; i++)
    {
      print('substr_${i} : ${vec__result[i]}');        //Выводим индексы найденых подстрок.
    }
  }

  //----------------------------------------------------------------find_substring_to_List:End---------------------------------------------------------------------




  //-------------------------------------------------------------------decode_UTF8_to_String:Begin---------------------------------------------------------------------
  //Декодирует внутренний буффер, как UTF-8 последовательность в Dart`овский UTF-16 String и возвращает его.
  //ВНИМАНИЕ: Использовать данную функцию ТОЛЬКО в том случае, если в внутреннем Uint8List буффере валидная UTF-8 кодировка - иначе код упадет с ошибкой в рантайме.

  String? decode_UTF8_to_String = Uint8List_class_.decode_UTF8_to_String();   //Если во внутреннем буффере находится невалидная UTF-8 последвтаельность, то возвратится null.

  if(decode_UTF8_to_String == null)
  {
    print('decode_UTF8_to_String:Incorrect UTF-8');
  }
  else
  {
    print('decode_UTF8_to_String:${decode_UTF8_to_String}');
  }
  //-------------------------------------------------------------------decode_UTF8_to_String:End---------------------------------------------------------------------


  //------------------------------------------------------------------print_only_WorkSize:Begin---------------------------------------------------------------------
  //Выводит на консоль только "рабочие" элементы, то есть сооветсующие фактическому размеру Uint8List_class_.size(), а не вcю емкость буффера Uint8List_class_.capacity()


  Uint8List_class_.print_only_WorkSize();

  //------------------------------------------------------------------print_only_WorkSize:End---------------------------------------------------------------------



  //----------------------------------------------------------------get__View_Type_Float32List:Begin----------------------------------------------------------

  //Вообщем y Uint8List и аналогичный "сырых" буфферов есть два полезных метода, которые работают в связке: это .View() и .buffer.
  //Вообщем суть: предположим есть буффер:

  Float32List Float32List_test = Float32List.fromList([1,2,3,4,5,6,7]);

  //Есть минимум два полезных способа, как можно использовать view и buffer:

  //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~1-Способ:Begin~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  //1-Способ: Предположим мне нужно получить "указатель" на третий элемент без всяких копирований, делается так: Вообщем это по сути механизм указателей из Си:

  Float32List Float32List_view = Float32List.view(Float32List_test.buffer, 2 * Float32List.bytesPerElement, 1);
  //Второй параметр - это смещение в БАЙТАХ(независио от типа сырового буффера), а третий элемент это длинна уже в элементах типа буффера.
  //То есть: если мне нужно получить указатель на третий элемент - нужно сдвинуть от начало буффера на индекс элемента умноженного на размер типа буффера и указать длинну уже в элементах типа буффера - в данном случае float32.

   print(Float32List_view);   //Выедетеся значение третьего float32 элемента.

  //Если же к примеру указать длинну в два элемента:

  Float32List_view = Float32List.view(Float32List_test.buffer, 2 * Float32List.bytesPerElement, 2);

  print(Float32List_view);   //То Выедетеся значение третьего и четвертого float32 элементов.

  print(Float32List_view[0]);   //При этом доступ к такому view-указателю по первому елементу, автомачтиески будет указывать естесвенно, на третий элемент из оргиниального буффера.
  //print(Float32List_view[2]);   //При этом выходит также естесвенно за пределы взятого view-указателя нелья, иначе просто падение в ранатйме.


  //ПРИ ЭТОМ стоит обратить ВНИМАНИЕ - что метд view - по сути возврашает тот же самый тип буффера "Float32List" без всяких копий, то есть это именно "указатель", как в С/С++.
  //Это может быть полезным к примеру в таком случае: предположим у нас есть все тот же буффер "Float32List_view" и есть функция, которая принимает "Float32List" буффер, НО предположим нам нужно предать только часть из нашего буффера, вот для этого .view() с указанием смещения и длинны и нужно - потому view() - возвращает тот же самый тип буффера "Float32List" - тоько как бы "урезанный", который можно передать уже в нужную функцию. Ну короче это максимально близкий аналог указателей Си, чем они навренео по сути и являются.
  //И не стоит забывать о времени жизни такого view-указателя, если изначальный буффер был "удален" или если элемента изнаачльного буффера были перезаписаны, то и view-указаетль автоматически будет или не валидный или автматически будет указывать на перезаписанные эленметы.

  //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~1-Способ:End~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



  //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~2-Способ:Begin~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  //Воспользуемся все тем же буффером из первого способа. Вообщем это по сути механизм приведения указателя к типу или "static_cast" из C и С++.

  //Что если я хочу рассматривать буффер из элментов Float32, как буффер из элементов Float64. Это делается так:

  Float64List Float64List_view_Static_Cast = Float64List.view(Float32List_test.buffer, 2 * Float64List.bytesPerElement, 1);

  //Собсвенно и все, теперь тут "Float64List_view_Static_Cast" - указатель приведенный к "Float64List" и теперь по "Float64List_view_Static_Cast" можно пермещатся, так, как будто он состоит из Float64 элементов.

  print(Float64List_view_Static_Cast[0]);   //То есть выводи значение из буффера "Float32List_view" начинающееся с элмента с 5-го элемента пиведенным к "Float64", который будет занимать два эдемента "Float32". Выход за пределы буффера нужно контролировать самостоятельно.


  //Float64List_view_Static_Cast = Float64List.view(Float32List_test.buffer, 2 * Float64List.bytesPerElement, 2);  //Так делать уже нельзя, так как указав длинну в 2 элемента "Float64" - мы по сути выходим за пределы буффера "Float32List_test".

   //И таким образом можно привести оригниальный буффер "Float32List_view" к любому из типов.
  //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~2-Способ:end~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


  //-------------------------------------------------------------------------------------------
  //НУ ТАК Я ЭТО К ЧЕМУ ВСЕ. К тому что методы:

  //get__View_Type_Float32List            - возвращает view-представление внутреннеого "Uint8List", как "указатель" на буффер "Float32List". Вообщем, возвращается, как бы указатель на внутренний буффер, но при индексировании по этому указателю элементы по индексу как бы "кастуются" или приводются к типу запрашваемого буффера. ДЛЯ примера: есть внутренний буффер "Uint8List" - пусть из 10 элементов, теперь запрашивает "укзаатель" на этот буффер "pointer_view = get__View_Type_Float32List()". pointer_view[0] - будет означать, что мы поулчает дсотуп к значению не первого байта Uint8List, а к значению приведенному к "Float32" - то есть первые 4-байта "Uint8List" - будут приведены к типу "float32", соотвевенно pointer_view[1] - уже будут приведены 4 байта начиначиная с 4 байта буффера "Uint8List" итд. НО внутри проверки на кратность размера типа запрашиваемого буффера нет, поэтому НУЖНО котролироват подобный доступ, потому что, если сделать уже так - pointer_view[2] - то будет указывать на 8 байт буффера "Uint8List" и пытатся привести 4 байта "float32" начиная с 8 байта, а размер нашего буффера "Uint8List" всего 10 байт!!! Это будет естесвенно ошибка, в лучем услучае упадет в рантайме, в худщем продолжит работать с некорректным результатом.
  //get__View_Type_Float64List            - возвращает view-представление внутреннеого "Uint8List", как "указатель" на буффер "Float64List". Вообщем, возвращается, как бы указатель на внутренний буффер, но при индексировании по этому указателю элементы по индексу как бы "кастуются" или приводются к типу запрашваемого буффера. ДЛЯ примера: есть внутренний буффер "Uint8List" - пусть из 10 элементов, теперь запрашивает "укзаатель" на этот буффер "pointer_view = get__View_Type_Float32List()". pointer_view[0] - будет означать, что мы поулчает дсотуп к значению не первого байта Uint8List, а к значению приведенному к "Float32" - то есть первые 4-байта "Uint8List" - будут приведены к типу "float32", соотвевенно pointer_view[1] - уже будут приведены 4 байта начиначиная с 4 байта буффера "Uint8List" итд. НО внутри проверки на кратность размера типа запрашиваемого буффера нет, поэтому НУЖНО котролироват подобный доступ, потому что, если сделать уже так - pointer_view[2] - то будет указывать на 8 байт буффера "Uint8List" и пытатся привести 4 байта "float32" начиная с 8 байта, а размер нашего буффера "Uint8List" всего 10 байт!!! Это будет естесвенно ошибка, в лучем услучае упадет в рантайме, в худщем продолжит работать с некорректным результатом.
  //get__View_Type_Int8List               - возвращает view-представление внутреннеого "Uint8List", как "указатель" на буффер "Int8List".    Вообщем, возвращается, как бы указатель на внутренний буффер, но при индексировании по этому указателю элементы по индексу как бы "кастуются" или приводются к типу запрашваемого буффера. ДЛЯ примера: есть внутренний буффер "Uint8List" - пусть из 10 элементов, теперь запрашивает "укзаатель" на этот буффер "pointer_view = get__View_Type_Float32List()". pointer_view[0] - будет означать, что мы поулчает дсотуп к значению не первого байта Uint8List, а к значению приведенному к "Float32" - то есть первые 4-байта "Uint8List" - будут приведены к типу "float32", соотвевенно pointer_view[1] - уже будут приведены 4 байта начиначиная с 4 байта буффера "Uint8List" итд. НО внутри проверки на кратность размера типа запрашиваемого буффера нет, поэтому НУЖНО котролироват подобный доступ, потому что, если сделать уже так - pointer_view[2] - то будет указывать на 8 байт буффера "Uint8List" и пытатся привести 4 байта "float32" начиная с 8 байта, а размер нашего буффера "Uint8List" всего 10 байт!!! Это будет естесвенно ошибка, в лучем услучае упадет в рантайме, в худщем продолжит работать с некорректным результатом.
  //get__View_Type_Int16List              - возвращает view-представление внутреннеого "Uint8List", как "указатель" на буффер "Int16List".   Вообщем, возвращается, как бы указатель на внутренний буффер, но при индексировании по этому указателю элементы по индексу как бы "кастуются" или приводются к типу запрашваемого буффера. ДЛЯ примера: есть внутренний буффер "Uint8List" - пусть из 10 элементов, теперь запрашивает "укзаатель" на этот буффер "pointer_view = get__View_Type_Float32List()". pointer_view[0] - будет означать, что мы поулчает дсотуп к значению не первого байта Uint8List, а к значению приведенному к "Float32" - то есть первые 4-байта "Uint8List" - будут приведены к типу "float32", соотвевенно pointer_view[1] - уже будут приведены 4 байта начиначиная с 4 байта буффера "Uint8List" итд. НО внутри проверки на кратность размера типа запрашиваемого буффера нет, поэтому НУЖНО котролироват подобный доступ, потому что, если сделать уже так - pointer_view[2] - то будет указывать на 8 байт буффера "Uint8List" и пытатся привести 4 байта "float32" начиная с 8 байта, а размер нашего буффера "Uint8List" всего 10 байт!!! Это будет естесвенно ошибка, в лучем услучае упадет в рантайме, в худщем продолжит работать с некорректным результатом.
  //get__View_Type_Int32List              - возвращает view-представление внутреннеого "Uint8List", как "указатель" на буффер "Int32List".   Вообщем, возвращается, как бы указатель на внутренний буффер, но при индексировании по этому указателю элементы по индексу как бы "кастуются" или приводются к типу запрашваемого буффера. ДЛЯ примера: есть внутренний буффер "Uint8List" - пусть из 10 элементов, теперь запрашивает "укзаатель" на этот буффер "pointer_view = get__View_Type_Float32List()". pointer_view[0] - будет означать, что мы поулчает дсотуп к значению не первого байта Uint8List, а к значению приведенному к "Float32" - то есть первые 4-байта "Uint8List" - будут приведены к типу "float32", соотвевенно pointer_view[1] - уже будут приведены 4 байта начиначиная с 4 байта буффера "Uint8List" итд. НО внутри проверки на кратность размера типа запрашиваемого буффера нет, поэтому НУЖНО котролироват подобный доступ, потому что, если сделать уже так - pointer_view[2] - то будет указывать на 8 байт буффера "Uint8List" и пытатся привести 4 байта "float32" начиная с 8 байта, а размер нашего буффера "Uint8List" всего 10 байт!!! Это будет естесвенно ошибка, в лучем услучае упадет в рантайме, в худщем продолжит работать с некорректным результатом.
  //get__View_Type_Int64List              - возвращает view-представление внутреннеого "Uint8List", как "указатель" на буффер "Int64List".   Вообщем, возвращается, как бы указатель на внутренний буффер, но при индексировании по этому указателю элементы по индексу как бы "кастуются" или приводются к типу запрашваемого буффера. ДЛЯ примера: есть внутренний буффер "Uint8List" - пусть из 10 элементов, теперь запрашивает "укзаатель" на этот буффер "pointer_view = get__View_Type_Float32List()". pointer_view[0] - будет означать, что мы поулчает дсотуп к значению не первого байта Uint8List, а к значению приведенному к "Float32" - то есть первые 4-байта "Uint8List" - будут приведены к типу "float32", соотвевенно pointer_view[1] - уже будут приведены 4 байта начиначиная с 4 байта буффера "Uint8List" итд. НО внутри проверки на кратность размера типа запрашиваемого буффера нет, поэтому НУЖНО котролироват подобный доступ, потому что, если сделать уже так - pointer_view[2] - то будет указывать на 8 байт буффера "Uint8List" и пытатся привести 4 байта "float32" начиная с 8 байта, а размер нашего буффера "Uint8List" всего 10 байт!!! Это будет естесвенно ошибка, в лучем услучае упадет в рантайме, в худщем продолжит работать с некорректным результатом.
  //get__View_Type_Uint8List              - возвращает view-представление внутреннеого "Uint8List", как "указатель" на буффер "Uint8List".   Вообщем, возвращается, как бы указатель на внутренний буффер, но при индексировании по этому указателю элементы по индексу как бы "кастуются" или приводются к типу запрашваемого буффера. ДЛЯ примера: есть внутренний буффер "Uint8List" - пусть из 10 элементов, теперь запрашивает "укзаатель" на этот буффер "pointer_view = get__View_Type_Float32List()". pointer_view[0] - будет означать, что мы поулчает дсотуп к значению не первого байта Uint8List, а к значению приведенному к "Float32" - то есть первые 4-байта "Uint8List" - будут приведены к типу "float32", соотвевенно pointer_view[1] - уже будут приведены 4 байта начиначиная с 4 байта буффера "Uint8List" итд. НО внутри проверки на кратность размера типа запрашиваемого буффера нет, поэтому НУЖНО котролироват подобный доступ, потому что, если сделать уже так - pointer_view[2] - то будет указывать на 8 байт буффера "Uint8List" и пытатся привести 4 байта "float32" начиная с 8 байта, а размер нашего буффера "Uint8List" всего 10 байт!!! Это будет естесвенно ошибка, в лучем услучае упадет в рантайме, в худщем продолжит работать с некорректным результатом.
  //get__View_Type_Uint16List             - возвращает view-представление внутреннеого "Uint8List", как "указатель" на буффер "Uint16List".  Вообщем, возвращается, как бы указатель на внутренний буффер, но при индексировании по этому указателю элементы по индексу как бы "кастуются" или приводются к типу запрашваемого буффера. ДЛЯ примера: есть внутренний буффер "Uint8List" - пусть из 10 элементов, теперь запрашивает "укзаатель" на этот буффер "pointer_view = get__View_Type_Float32List()". pointer_view[0] - будет означать, что мы поулчает дсотуп к значению не первого байта Uint8List, а к значению приведенному к "Float32" - то есть первые 4-байта "Uint8List" - будут приведены к типу "float32", соотвевенно pointer_view[1] - уже будут приведены 4 байта начиначиная с 4 байта буффера "Uint8List" итд. НО внутри проверки на кратность размера типа запрашиваемого буффера нет, поэтому НУЖНО котролироват подобный доступ, потому что, если сделать уже так - pointer_view[2] - то будет указывать на 8 байт буффера "Uint8List" и пытатся привести 4 байта "float32" начиная с 8 байта, а размер нашего буффера "Uint8List" всего 10 байт!!! Это будет естесвенно ошибка, в лучем услучае упадет в рантайме, в худщем продолжит работать с некорректным результатом.
  //get__View_Type_Uint32List             - возвращает view-представление внутреннеого "Uint8List", как "указатель" на буффер "Uint32List".  Вообщем, возвращается, как бы указатель на внутренний буффер, но при индексировании по этому указателю элементы по индексу как бы "кастуются" или приводются к типу запрашваемого буффера. ДЛЯ примера: есть внутренний буффер "Uint8List" - пусть из 10 элементов, теперь запрашивает "укзаатель" на этот буффер "pointer_view = get__View_Type_Float32List()". pointer_view[0] - будет означать, что мы поулчает дсотуп к значению не первого байта Uint8List, а к значению приведенному к "Float32" - то есть первые 4-байта "Uint8List" - будут приведены к типу "float32", соотвевенно pointer_view[1] - уже будут приведены 4 байта начиначиная с 4 байта буффера "Uint8List" итд. НО внутри проверки на кратность размера типа запрашиваемого буффера нет, поэтому НУЖНО котролироват подобный доступ, потому что, если сделать уже так - pointer_view[2] - то будет указывать на 8 байт буффера "Uint8List" и пытатся привести 4 байта "float32" начиная с 8 байта, а размер нашего буффера "Uint8List" всего 10 байт!!! Это будет естесвенно ошибка, в лучем услучае упадет в рантайме, в худщем продолжит работать с некорректным результатом.
  //get__View_Type_Uint64List             - возвращает view-представление внутреннеого "Uint8List", как "указатель" на буффер "Uint64List".  Вообщем, возвращается, как бы указатель на внутренний буффер, но при индексировании по этому указателю элементы по индексу как бы "кастуются" или приводются к типу запрашваемого буффера. ДЛЯ примера: есть внутренний буффер "Uint8List" - пусть из 10 элементов, теперь запрашивает "укзаатель" на этот буффер "pointer_view = get__View_Type_Float32List()". pointer_view[0] - будет означать, что мы поулчает дсотуп к значению не первого байта Uint8List, а к значению приведенному к "Float32" - то есть первые 4-байта "Uint8List" - будут приведены к типу "float32", соотвевенно pointer_view[1] - уже будут приведены 4 байта начиначиная с 4 байта буффера "Uint8List" итд. НО внутри проверки на кратность размера типа запрашиваемого буффера нет, поэтому НУЖНО котролироват подобный доступ, потому что, если сделать уже так - pointer_view[2] - то будет указывать на 8 байт буффера "Uint8List" и пытатся привести 4 байта "float32" начиная с 8 байта, а размер нашего буффера "Uint8List" всего 10 байт!!! Это будет естесвенно ошибка, в лучем услучае упадет в рантайме, в худщем продолжит работать с некорректным результатом.

  //Это просто минимальная обертка над .view и буффер, чтобы не нужо было вручную умножать размер типа на смещаемые байты, а сразу указать номер элемента того типа, который запрашивается.
  //Вот так:

  Float64List Float64List_view_Static_Cast_1 = Uint8List_class_.get__View_Type_Float64List(2, 1);   //Получаем приведенный указатель на Float64List внутреннего буффера начиная с третего элемента "Float64" размером в один элемент.

  print(Float64List_view_Static_Cast_1);
  //-------------------------------------------------------------------------------------------


  //----------------------------------------------------------------get__View_Type_Float32List:End----------------------------------------------------------



  //******************************************************************Uint8List__class:Конец*********************************************************************

}
